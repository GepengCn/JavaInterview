### SpringMVC 工作原理

--- 

简单来说就是客户端发送一次请求，SpringMVC怎么处理的

1. 客户端发送请求到**前端控制器**`DispatcherServlet`
2. 调用`HandlerMapping`,解析请求对应的Handler(即`Controller`)
3. 由`HandlerAdapter`负责处理`handler`请求，并执行`handler`里的业务逻辑
4. 返回一个`ModelAndView`对象,`Model`是返回的数据对象,`View`是个逻辑上的`View`
5. `ViewResolver`会根据`View`查找实际的`View`
6. `DispatcherServlet`会将`Model`填充到`View`
7. 把`View`返回给请求者



?> `DispatcherServlet`:SpringMVC入口,接收请求、响应结果，整个流程的控制中心。

?> `HandlerMapping`:根据请求的url查找对应Handler

?> `HandlerAdapter`:负责真正处理的`Handler`的适配器

?> `Handler`:实现业务逻辑的地方(Controller)，**需要自己实现**

?> `View resolver`:视图解析器，负责从逻辑视图中解析到真正的视图

?> `View`:实现前台展示,**需要自己实现**

### 说一下自己对 IOC 、AOP 的理解

---

#### Spring AOP


?> 一种面向切面的编程思想,将许多业务流程中的**通用功能或者说是系统功能**抽取出来，形成独立的切面，在合适的时机将切面切入到流程的指定位置中，分离应用的**业务逻辑**与**系统级功能**进行内聚性的开发，应用只负责实现**业务逻辑**而不必关心其它
   
!>  通知(`Advice`)

> 通知有5种类型：


- `Before`
在方法被调用之前调用


- `After`
在方法完成后调用通知，无论方法是否执行成功


- `After-returning`
在方法成功执行之后调用通知


- `After-throwing`
在方法抛出异常后调用通知


- `Around`
通知了好、包含了被通知的方法，在被通知的方法调用之前后调用之后执行自定义的行为

!> 切点（`Pointcut`)

定义了切面要发生的地方

!> 连接点（`Joint point`）

方法的执行点

!> 引入（`Introduction`）

引用允许我们向现有的类添加新的方法或者属性

!> 织入（`Weaving`）

将 `aspect` 和其他对象连接起来, 并创建 `adviced` `object` 的过程.
根据不同的实现技术, `AOP`织入有三种方式:

- 编译器织入, 这要求有特殊的`Java`编译器.

- 类装载期织入, 这需要有特殊的类装载器.

- 动态代理织入, 在运行期为目标类添加增强(`Advice`)生成子类的方式.
`Spring` 采用动态代理织入, 而`AspectJ`采用编译器织入和类装载期织入.

!> 目标对象(`Target`)

织入`advice`的目标对象. 目标对象也被称为`advised object`.

因为 `Spring` `AOP` 使用运行时代理的方式来实现 `aspect`, 因此 `adviced object` 总是一个代理对象(`proxied object`)

注意, `adviced object` 指的不是原来的类, 而是织入 `advice` 后所产生的代理类.

!> AOP proxy

一个类被 `AOP` 织入 `advice`, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类.

在 `Spring AOP` 中, 一个 `AOP` 代理是一个 `JDK` 动态代理对象或 `CGLIB` 代理对象.

#### IOC

?> Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：

!> **谁控制谁，控制什么**：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；**谁控制谁？**当然是IoC 容器控制了对象；**控制什么？**那就是主要控制了外部资源获取（不只是对象包括比如文件等）。

!> **为何是反转，哪些方面反转了**：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；**为何是反转？**因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；**哪些方面反转了？**依赖对象的获取被反转了。