## Java基础

### 面向对象

- 简单理解
```
面向对象和面向过程的思想有着本质上的区别。
 作为面向对象的思维来说，当你拿到一个问题时，你分析这个问题不再是第一步先做什么，第二步再做什么，这是面向过程的思维。
你应该分析这个问题里面有哪些类和对象，这是第一点，
然后再分析这些类和对象应该具有哪些属性和方法。这是第二点。
最后分析类和类之间具体有什么关系，这是第三点。
面向对象有一个非常重要的设计思维：合适的方法应该出现在合适的类里面。
```
- 设计思想
```
面向对象的基本思想是，
从现实世界中客观存在的事物出发来构造软件系统
并在系统的构造中尽可能运用人类的自然思维方式。

面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。

人在思考的时候，首先眼睛里看到的是一个一个的对象。
```
- 对象和类的概念
```
对象是用于计算机语言对问题域中事物的描述，
对象通过“属性（attribute）”和“方法（method）”来分别对应事物所具有的静态属性和动态属性。

类是用于描述同一类的对象的一个抽象的概念，
类中定义了这一类对象所具有的静态属性和动态属性

类可以看成一类对象的模板，
对象可以看成该类的一个具体实例。
```
- 引用
https://www.cnblogs.com/xdp-gacl/p/3624100.html

### 面向对象和面向过程的区别

- 面向过程
```
优点： 性能比面向对象高，因为类调用时需要实例化，
开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，
性能是最重要的因素。

缺点： 没有面向对象易维护、易复用、易扩展
```
- 面向对象
```
优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，
可以设计出低耦合的系统，使系统更加灵活、更加易于维护

缺点： 性能比面向过程低
```

### 面向对象三大特性

- 封装
```
也就是把客观事物封装成抽象的类，
并且类可以把自己的数据和方法只让可信的类或者对象操作，
对不可信的进行信息隐藏。封装是面向对象的特征之一，
是对象和类概念的主要特性。 
简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。
在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。
通过这种方式，对象对内部数据提供了不同级别的保护，
以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
```
- 继承
```
是指可以让某个类型的对象获得另一个类型的对象的属性的方法。
它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，
并在无需重新编写原来的类的情况下对这些功能进行扩展。 
通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。
继承的过程，就是从一般到特殊的过程。
要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
继承概念的实现方式有二类：实现继承与接口继承。
实现继承是指直接使用基类的属性和方法而无需额外编码的能力；
接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。
```
- 多态
```
就是指一个类实例的相同方法在不同情形有不同表现形式。
多态机制使具有不同内部结构的对象可以共享相同的外部接口。
这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，
它们（那些操作）可以通过相同的方式予以调用。
```


### 五大基本原则

- 单一职责原则SRP(Single Responsibility Principle)
```
是指一个类的功能要单一，不能包罗万象。如同一个人一样，
分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。
```
- 开放封闭原则OCP(Open－Close Principle)
```
一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。
比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，
那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，
这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。
```
- 里氏替换原则(the Liskov Substitution Principle LSP)
```
子类应当可以替换父类并出现在父类能够出现的任何地方。
比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，
也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。
```
- 依赖倒置原则(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，
```
这个时候，B不应当直接使用A中的具体类： 
而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：
这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。
通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，
那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，
而编译B时同样要直接包含到A的cpp文件。
```
- 接口分离原则(the Interface Segregation Principle ISP)
```
模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来
```

- 迪米特法则
```
迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写LKP），
就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。
英文简写为: LoD.迪米特法则可以简单说成：talk only to your immediate friends。 
对于面向OOD来说，又被解释为下面几种方式：
一个软件实体应当尽可能少的与其他实体发生相互作用。
每一个软件单位对其他的单位都只有最少的知识，
而且局限于那些与本单位密切相关的软件单位。

　　迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，
因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。
迪米特法则不希望类直接建立直接的接触。如果真的有需要建立联系，
也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：
系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。
有兴趣可以研究一下设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。
```
### 重载和重写

- 重载

    -  重载Overload是一个类中多态性的一种表现。是编译时的多态性。方法重载是让类以统一的方式处理不同类型数据的一种手段。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。
    -  Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数列表。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。
    - 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。
    - 不能通过访问权限、返回类型、抛出的异常进行重载；
    - 方法的异常类型和数目不会对重载造成影响；

- 重写

    - 父类与子类之间的多态性，对父类的函数进行重新定义。是运行时的多样性。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Override)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。
    - 若子类中的方法与父类中的某一方法具有相同的方法名、参数列表和兼容的返回类型，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。
    - 子类函数的访问修饰权限不能少于父类的。

### 接口和抽象类

- 语法层面上的区别

    - 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

    - 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

    - 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

    - 一个类只能继承一个抽象类，而一个类却可以实现多个接口。
- 设计层面上的区别

    - 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

    - 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。
- 引用
https://www.cnblogs.com/dolphin0520/p/3811437.html

### 成员变量与局部变量的区别

- 在类中的位置不同

    - 成员变量：在类中方法外面

    - 局部变量：在方法或者代码块中，或者方法的声明上（即在参数列表中）

- 在内存中的位置不同，可以看看Java程序内存的简单分析

    - 成员变量：在堆中（方法区中的静态区）

    - 局部变量：在栈中

- 生命周期不同

    - 成员变量：随着对象的创建而存在，随着对象的消失而消失

    - 局部变量：随着方法的调用或者代码块的执行而存在，随着方法的调用完毕或者代码块的执行完毕而消失

- 初始值

    - 成员变量：有默认初始值

    - 局部变量：没有默认初始值，使用之前需要赋值，否则编译器会报错（The local variable xxx may not have been initialized）
### ==与equals

== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)

equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

### hashcode与equals


- 引用
https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#27-hashcode-%E4%B8%8E-equals%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89

### 线程、进程与程序
- 程序只是一组指令的有序集合。

- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位;

- 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),一个线程可以创建和撤销另一个线程;

- 引用
https://www.cnblogs.com/aquarius-bear/p/3939939.html

### 线程基本状态

![Alt text][thread_status]
1. 新建

用new语句创建的线程对象处于新建状态，此时它和其他java对象一样，仅被分配了内存。

2. 等待

当线程在new之后，并且在调用start方法前，线程处于等待状态。

3. 就绪

当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态。处于这个状态的线程位于Java虚拟机的可运行池中，等待cpu的使用权。

4. 运行状态

处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任何时刻只会有一个线程处于这个状态。

只有处于就绪状态的线程才有机会转到运行状态。

5. 阻塞状态

阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，它才会有机会获得运行状态
```
阻塞状态分为三种:

1、等待阻塞:运行的线程执行wait（）方法，JVM会把该线程放入等待池中。

2、同步阻塞:运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中。

3、其他阻塞:运行的线程执行Sleep（）方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。当Sleep（）状态超时、或者I/O处理完毕时，线程重新转入就绪状态。
```
6.死亡状态

当线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，此时就进入死亡状态，该线程结束生命周期。

### 异常与错误

1. 异常分类

![Alt text][errorAndException]

可以看出，所有的异常都是由Throwable类，下一层分解为两个分支：Error和Exceprion。 
Error层次结构描述了java运行时系统的内部错误和资源耗尽错误。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。应用程序不应该抛出这种类型的对象。 
Exceprion这个层次结构又分解为连个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有没有问题，但由于像I/O错误这类异常导致的异常属于其他异常。 

```
常见的RuntimeException（运行时异常）： 
IndexOutOfBoundsException(下标越界异常) 
NullPointerException(空指针异常) 
NumberFormatException （String转换为指定的数字类型异常） 
ArithmeticException -（算术运算异常 如除数为0） 
ArrayStoreException - （向数组中存放与声明类型不兼容对象异常） 
SecurityException -（安全异常） 
IOException（其他异常） 
FileNotFoundException（文件未找到异常。） 
IOException（操作输入流和输出流时可能出现的异常。） 
EOFException （文件已结束异常）
```

2. 概念理解
> 首先明白下面的两个概念 
unchecked exception（非检查异常）：包括运行时异常（RuntimeException）和派生于Error类的异常。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。 
checked exception（检查异常，编译异常，必须要处理的异常） 
也：称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。

3. 异常处理与实际使用

`https://blog.csdn.net/m0_37531231/article/details/79502778`


### String、StringBuffer与StringBuilder

> 这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。

1. 首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder > StringBuffer > String

String最慢的原因：

String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。

2.  再来说线程安全

在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的

3. 总结一下

String：适用于少量的字符串操作的情况

StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况

StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况

<!--
[thread_status]:https://github.com/GepengCn/JavaInterview/blob/master/resources/thread_status.jpg?raw=true

[errorAndException]:https://github.com/GepengCn/JavaInterview/blob/master/resources/errorAndException.jpeg?raw=true
-->
